#进程线程协程
>+ 进程和线程        
> 
> 进程就是一个程序在一个数据集上的一次动态执行过程（数据集是程序在执行过程中所需要使用的资源）。
> 线程也叫轻量级进程，它是一个基本的 CPU 执行单元，是比进程更小的能独立运行的基本单位。
> 
>+ 进程和线程的关系：     
> 
> 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 
> 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 
> CPU 分给线程，即真正在 CPU 上运行的是线程。
> 
>+ 三者的一些相互关系
> 
> 共享同一个地址空间的线程组成了一个进程。一个线程内可有多个协程
> 先有进程，然后进程可以创建线程，线程是依附在进程里面的， 线程里面可以包含多个协程         
> 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题       
> 多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大       
> 多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行      
> 协程以后主要用在网络爬虫和网络请求     

#线程同步
> 由于一个进程的多个线程公用同一个存储空间，会带来访问的冲突问题。       
> 为了保证数据在访问中的正确性，在访问时加入锁机制。     
> 当一个线程获得对象的排他锁，独占资源，其他线程必须等待，等锁释放。
> 带来问题      
>+ 一个线程持有锁会导致其他所有需要此锁的线程挂起。
>+ 多线程竞争下，加锁，释放会导致较多的切换，调度延时，存在性能问题。
>+ 如果一个高优先级的线程等待一个低优先级的线程释放锁，会导致优先级倒置，引起性能问题。       

#死锁
> 多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能运行。导致两个或多个线程都在等待对方释放资源，都停止运行。     
> 某一个同步块同时拥有“两个以上对象锁”时，就可能发生死锁问题。

#lock锁
> jdk5.0开始，java提供了更强到的线程同步机制lock锁
> lcok锁是显示定义同步锁对对象实现同步
> juc包下得lock接口是控制多个线程对共享资源进行访问。
> 锁提供了对共享资源的独占访问，每次只能有一个线程对lock对象加锁。线程考试访问共享资源前应先获得lock对象。
> synchronized与lock的对比
> + lcok是显式锁（手动开关），synchronized是隐式锁，出了作用域自动释放。
> + lcok只有代码块锁，synchronized有代码块锁和方法锁。
> + 使用lock锁，jvm调度线程时间较少，扩展性也较好。
> + 使用中，lock > 同步代码块 > 同步方法。

#线程协作

> + 管程法（并发协作模式，“生产者消费者模式”）        
> 生产者：负责产生数据的模块（可能是方法，对象，线程，进程）     
> 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）     
> 缓冲区：消费者不直接使用生产者的数据，生产者将数据放入缓冲区，消费者从缓冲区拿       

> + 信号灯法
> 利用一个标志位，生产者消费者交替。

#线程池
> 类似sql中的连接池
> 经常创建销毁线程，尤其是并发情况下，浪费资源。
> 提前创建好多个线程，放入线程池。使用时直接获取，使用完放回。
> + 好处      
> 提高速度（减少创建时间），降低资源消耗（不需要每次都创建）。        
> 便于线程管理