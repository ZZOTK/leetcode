# 进程线程协程

>+ 进程和线程        
> 
> 进程就是一个程序在一个数据集上的一次动态执行过程（数据集是程序在执行过程中所需要使用的资源）。
> 线程也叫轻量级进程，它是一个基本的 CPU 执行单元，是比进程更小的能独立运行的基本单位。
> 
>+ 进程和线程的关系：     
> 
> 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 
> 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 
> CPU 分给线程，即真正在 CPU 上运行的是线程。
> 
>+ 三者的一些相互关系
> 
> 共享同一个地址空间的线程组成了一个进程。一个线程内可有多个协程
> 先有进程，然后进程可以创建线程，线程是依附在进程里面的， 线程里面可以包含多个协程         
> 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题       
> 多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大       
> 多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行      
> 协程以后主要用在网络爬虫和网络请求     

# 线程同步
> 由于一个进程的多个线程公用同一个存储空间，会带来访问的冲突问题。       
> 为了保证数据在访问中的正确性，在访问时加入锁机制。     
> 当一个线程获得对象的排他锁，独占资源，其他线程必须等待，等锁释放。
> 带来问题      
>+ 一个线程持有锁会导致其他所有需要此锁的线程挂起。
>+ 多线程竞争下，加锁，释放会导致较多的切换，调度延时，存在性能问题。
>+ 如果一个高优先级的线程等待一个低优先级的线程释放锁，会导致优先级倒置，引起性能问题。       

# 死锁
> 多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能运行。导致两个或多个线程都在等待对方释放资源，都停止运行。     
> 某一个同步块同时拥有“两个以上对象锁”时，就可能发生死锁问题。
> 死锁是满足四个条件后才出现的，它们分别是
> + 互斥
> + 保持和等待
> + 不可抢占
> + 循环等待       
> 
> 按理说破坏其中的任意一个条件就能够破坏死锁

# lock锁
> jdk5.0开始，java提供了更强到的线程同步机制lock锁
> lcok锁是显示定义同步锁对对象实现同步
> juc包下得lock接口是控制多个线程对共享资源进行访问。
> 锁提供了对共享资源的独占访问，每次只能有一个线程对lock对象加锁。线程考试访问共享资源前应先获得lock对象。
> synchronized与lock的对比
> + lcok是显式锁（手动开关），synchronized是隐式锁，出了作用域自动释放。
> + lcok只有代码块锁，synchronized有代码块锁和方法锁。
> + 使用lock锁，jvm调度线程时间较少，扩展性也较好。
> + 使用中，lock > 同步代码块 > 同步方法。

# 两阶段加锁
> 2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。        
> 2PC,两阶段提交协议:主要用于分布式事务。        
> 下面聊一聊MySql(仅限innodb)的两阶段加锁(2PL)协议     
> 在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。      

# 通讯死锁
> 资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。        
> 进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生死锁。       
> 通讯死锁中使用超时(timeout)来解决死锁问题


# 活锁
> 某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。
> 现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 活锁(livelock)。

# 饥饿
> 与死锁和活锁的一个非常相似的问题是 饥饿(starvvation)。对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。
> 我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。


# 线程协作
> + 管程法（并发协作模式，“生产者消费者模式”）        
> 生产者：负责产生数据的模块（可能是方法，对象，线程，进程）     
> 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）     
> 缓冲区：消费者不直接使用生产者的数据，生产者将数据放入缓冲区，消费者从缓冲区拿       

> + 信号灯法
> 利用一个标志位，生产者消费者交替。


# 线程池
> 类似sql中的连接池
> 经常创建销毁线程，尤其是并发情况下，浪费资源。
> 提前创建好多个线程，放入线程池。使用时直接获取，使用完放回。
> + 好处      
> 提高速度（减少创建时间），降低资源消耗（不需要每次都创建）。        
> 便于线程管理