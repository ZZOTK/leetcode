## 什么是分布式锁
当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。

分布式锁的作用：在整个系统提供一个全局、唯一的锁，在分布式系统中每个系统在进行相关操作的时候需要获取到该锁，才能执行相应操作。
## 分布式锁的实现

1. redis分布式锁
2. zookeeper分布式锁
3. 数据库分布式锁

## redis分布式锁

redis的setnx()指令： 

* setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。

redis的expire()

* expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。

步骤： 
1. setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功
2. expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。
3. 执行完业务代码后，可以通过 delete 命令删除 key。

这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。
比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。

Redis 的 RedLock 算法

使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。

1. 尝试从 N 个互相独立 Redis 实例获取锁；
2. 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
3. 如果获取锁失败，就到每个实例上释放锁。

## 数据库分布式锁
利用数据库的唯一索引来做分布式锁

获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。

存在以下几个问题：

* 锁没有失效时间，解锁失败的话其它进程无法再获得该锁；
* 只能是非阻塞锁，插入失败直接就报错了，无法重试；
* 不可重入，已经获得锁的进程也必须重新获取锁

## zookeeper分布式锁

* 利用Zookeeper可以创建临时带序号节点的特性来实现一个分布式锁
* 多个系统的多个线程都要在此目录下创建临时的顺序节点，因为Zk会为我们保证节点的顺序性，
    * 所以可以利用节点的顺序性来对不同线程的先来后到进行判断。此时，在分布式下应该添加锁的线程就是zk指定目录下序号最小的临时序列节点所代表的线程。
* 当每个线程请求对应资源时，都需要先在zk指定目录下创建临时顺序节点，然后获取当前目录下最小的节点序号(加锁的线程)，判断最小节点是不是当前节点(判断是不是自己)，
    * 如果是那么获取锁成功，如果不是那么获取锁失败。
* 获取锁失败的线程获取当前节点上一个临时顺序节点，并对对此节点进行监听。当该节点删除的时候(上一个线程执行结束删除或者是掉线zk删除临时节点)这个线程会获取到通知，代表获取到了锁。 
    * 注意这里每个节点都是只监听它的上一个节点即可，而不是监听序号最小的节点。因为临时节点都是带序号的，而且序号不会回退，所以只需要 监听比其小1的节点。只要比它小1的节点被清除，则它就可以 拿到资源去操作
    
优点:
* 客户端如果出现宕机故障的话，锁可以马上释放 
* 可以实现阻塞式锁，通过 watcher 监听，实现起来也比较简单
* 集群模式，稳定性比较高

缺点
* 一旦网络有任何的抖动，Zookeeper 就会认为客户端已经宕机，就会断掉连接，其他客户端就可以获取到锁。当然 Zookeeper 有重试机制，这个就比较依赖于其重试机制的策略了
* 性能上不如缓存



