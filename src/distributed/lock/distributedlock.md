## 什么是分布式锁
当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。

## 分布式锁的实现

1. redis分布式锁
2. zookeeper分布式锁
3. 数据库分布式锁

## redis分布式锁

redis的setnx()指令： 

* setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。

redis的expire()

* expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。

步骤： 
1. setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功
2. expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。
3. 执行完业务代码后，可以通过 delete 命令删除 key。

这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。
比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。

Redis 的 RedLock 算法

使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。

1. 尝试从 N 个互相独立 Redis 实例获取锁；
2. 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
3. 如果获取锁失败，就到每个实例上释放锁。

## 数据库分布式锁
利用数据库的唯一索引来做分布式锁

获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。

存在以下几个问题：

* 锁没有失效时间，解锁失败的话其它进程无法再获得该锁；
* 只能是非阻塞锁，插入失败直接就报错了，无法重试；
* 不可重入，已经获得锁的进程也必须重新获取锁

## zookeeper分布式锁

获取锁：
1. 先有一个锁跟节点，lockRootNode，这可以是一个永久的节点
2. 客户端获取锁，先在 lockRootNode 下创建一个顺序的瞬时节点，保证客户端断开连接，节点也自动删除
3. 调用 lockRootNode 父节点的 getChildren() 方法，获取所有的节点，并从小到大排序，如果创建的最小的节点是当前节点，则返回 true,获取锁成功，否则，关注比自己序号小的节点的释放动作(exist watch)，这样可以保证每一个客户端只需要关注一个节点，不需要关注所有的节点，避免羊群效应。
4. 如果有节点释放操作，重复步骤 3

释放锁:

只需要删除步骤 2 中创建的节点即可

优点:
* 客户端如果出现宕机故障的话，锁可以马上释放 
* 可以实现阻塞式锁，通过 watcher 监听，实现起来也比较简单
* 集群模式，稳定性比较高

缺点
* 一旦网络有任何的抖动，Zookeeper 就会认为客户端已经宕机，就会断掉连接，其他客户端就可以获取到锁。当然 Zookeeper 有重试机制，这个就比较依赖于其重试机制的策略了
* 性能上不如缓存



