# MQ概述
MQ全称 Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信。

1. MQ—消息队列，存储消息的中间件。
2. 分布式系统通信两种方式：直接远程调用和==借助第三方完成间接通信==。
3. 发送方称为生产者，接收方称为消费者。

## MQ的优劣势
MQ的优势：
1. 应用解耦 ：提高系统的容错性和可维护性
2. 异步提速 : 提升用用户体验和系统吞吐量（单位时间内处理请求的数目）
3. 削峰填谷 ： 提高系统稳定性

MQ的劣势：
1. 系统可用性降低
   * 系统引入的外部依赖越多，系统稳定性能越差。一旦MQ宕机，就会对业务造成影响。
2. 系统的复杂度提高
   * 如何保证消息没有被重复消费，如何处理消息丢失，保证消息传递的顺序性。
3. 一致性问题
   * 如何保证消息数据处理的一致性。 

### 使用 MQ 需要满足什么条件呢？
1. 生产者不需要从消费者处获得反馈。
    * 引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。
2. 容许短暂的不一致性。
3. 解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。

# RabbitMQ运转流程
生产者发送消息：
1. 生产者创建连接（connection），开启一个信道，连接到RabbitMQ Broker;
2. 申明队列并设置属性（是否排他，是否持久化，是否自动删除）；
3. 将路由键（空字符串）与队列绑定起来；
4. 发送消息至RabbitMQ Broker；
5. 关闭信道；
6. 关闭连接；

消费者接受消息：
1. 消费者创建连接，开启一个信道，连接到RabbitMQ Broker
2. 向Broker 请求消费相应队列中的消息，设置相应的回调函数；
3. 等待Broker回应闭关投递响应队列中的消息，消费者接收消息；
4. 确认（ack，自动确认）接收到的消息；
5. RabbitMQ从队列中删除相应已经被确认的消息；
6. 关闭信道
7. 关闭连接

# RabbitMQ工作模式
1. Helloworld简单模式
2. Work queues工作队列模式：
   ![img.png](workqueue.png)
    * 一个或一些消费端，多个消费端竞争消费同一个队列中的消息。
    * 在一个Work queues队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系
3. Publish/Subscribe发布订阅模式    
![img.png](publish.png)
    * P：生产者，不再发送消息到队列中，而是发给X（交换机）
    * C：消费者，消息的接受者，会一直等待消息到来。
    * Queue：消息队列，接收消息、缓存消息。
    * Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：
        * Fanout：广播，将消息交给所有绑定的交换机的队列
        * Direct：定向，把消息交给符合指定routing key的队列
        * Topic：通配符，把消息交给符合routing pattern（路由模式）的队列
    
总结：     
* 交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者收到。
* 布订阅模式与工作队列模式的区别，重点还是在交换机上面
* 工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。
* 发布/订阅模式的**生产方是面向交换机发送消息**，工作队列模式的生产方是**面向队列发送消息**(底层使用默认交换机)。
* 发布/订阅模式需要**设置队列和交换机的绑定**，工作队列模式不需要设置，实际上工作队列模式会将队列绑定到默认的交换机 。
4. Routing路由模式
* 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）
* 消息的发送方在向Exchange发送消息时，也必须指定消息的 RoutingKey。
* Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息
![img.png](routing.png)
* Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。
5. 