## 进程和线程        

* 进程就是一个程序在一个数据集上的一次动态执行过程（数据集是程序在执行过程中所需要使用的资源）。
* 线程也叫轻量级进程，它是一个基本的 CPU 执行单元，是比进程更小的能独立运行的基本单位。
* 每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

### Q：程序计数器为什么是私有的?
程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。

### Q：虚拟机栈和本地方法栈为什么是私有的?
为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。
 
## 进程和线程的关系：     

* 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 
* 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 
* CPU 分给线程，即真正在 CPU 上运行的是线程。

## 进程线程协程的一些相互关系
 
* 共享同一个地址空间的线程组成了一个进程。一个线程内可有多个协程
* 先有进程，然后进程可以创建线程，线程是依附在进程里面的， 线程里面可以包含多个协程         
* 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题       
* 多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大       
* 多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行      
* 协程以后主要用在网络爬虫和网络请求     

### Q：使用多线程可能带来什么问题?
并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

## 线程的创建
有四种使用线程的方法：
* 实现 Runnable 接口；
* 实现 Callable 接口；
* 继承 Thread 类。
* 线程池创建

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的


### Q：为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 
start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结： **调用 start() 方法方可启动线程并使线程进入就绪状态**（start启动线程），直接执行 run() 方法的话不会以多线程的方式执行。

## 线程通讯
1. while轮询的方式
    * 最朴素的方法。一个线程不断去询问另一个线程的状态。cpu资源很大的浪费。
    
2. Synchronized、wait、notify（等待/唤醒机制）
    * wait(): 让线程处于冻结状态，被wait的线程会被存储到线程池中。 如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。

    * notify():唤醒线程池中一个线程(任意)。如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。

    * notifyAll():唤醒线程池中的所有线程。如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。

本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。

3. volatile
    * volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。

4. join()
    * 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

5. CountDownLatch 
    * 用来控制一个或者多个线程等待多个线程。
    * 维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

6. CyclicBarrier
    * 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

    * 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

    * CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

    * CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。

7. Semaphore
    * Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。

    * 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

## JMM
Java的并发采用的是共享内存模型



## 线程同步
* 由于一个进程的多个线程公用同一个存储空间，会带来访问的冲突问题。       
* 为了保证数据在访问中的正确性，在访问时加入锁机制。     
* 当一个线程获得对象的排他锁，独占资源，其他线程必须等待，等锁释放。

带来问题  :    
* 一个线程持有锁会导致其他所有需要此锁的线程挂起。
* 多线程竞争下，加锁，释放会导致较多的切换，调度延时，存在性能问题。
* 如果一个高优先级的线程等待一个低优先级的线程释放锁，会导致优先级倒置，引起性能问题。       

## 并发与并行
* 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
* 并行： 单位时间内，多个任务同时执行。

## 并发编程的三个重要特性
* 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。
* 可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。
* 有序性 ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。

## ArrayList线程安全吗？不安全怎么解决。
ArrayList线程不安全，多线程操作会报出 ConcurrentModificationException（并发修改异常）错误。           
解决方法：
* List<String> list = new Vector<>(); vector线程安全,但是对所有操作都加了syn方法，速度慢
* List<String> list =  Collections.synchronizedList(new ArrayList<>());  collections包下的synchronizedlist线程安全
* List<String> list =  new CopyOnWriteArrayList<>(); JUC包下的 

# 线程的状态 
也就是**线程的生命周期和状态**：
* NEW 新生
* RUNNABLE 运行
* BLOCKED 阻塞
* WAITING 等待
* TIMED_WAITING 超时等待
* TERMINATED 终止

## Q：线程wait和sleep的区别
* 来自不同的类
    * wait来自Object类，sleep来自Thread类
* 锁的释放不同
    * wait方法会释放锁，sleep方法不释放锁
* 使用范围不同
    * sleep可以在任何范围使用。wait必须在同步代码块中使用。
* 是否需要捕获异常
    * wait不需要捕获异常，sleep必须捕获异常。

# 死锁
多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能运行。导致两个或多个线程都在等待对方释放资源，都停止运行。         
某一个同步块同时拥有“两个以上对象锁”时，就可能发生死锁问题。     
* 死锁是满足四个条件后才出现的，它们分别是  
  * 互斥          
  * 保持和等待
  * 不可抢占
  * 循环等待       
 
破坏其中的任意一个条件就能够破坏死锁

# lock锁
jdk5.0开始，java提供了更强到的线程同步机制lock锁     
lcok锁是显示定义同步锁对对象实现同步        
juc包下得lock接口是控制多个线程对共享资源进行访问。         
锁提供了对共享资源的独占访问，每次只能有一个线程对lock对象加锁。线程考试访问共享资源前应先获得lock对象。  

* ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。

## Q：synchronized与lock的对比： 
* lcok是显式锁（手动开关），synchronized是隐式锁，出了作用域自动释放。
* lcok只有代码块锁，synchronized有代码块锁和方法锁。
* 使用lock锁，jvm调度线程时间较少，扩展性也较好。
* 使用中，lock > 同步代码块 > 同步方法。

## Q:Synchronized与lock的区别
1. Syn是java的一个关键字，而lock是一个类。
2. Syn无法获取锁的状态，lock可以。
3. Syn会自动释放锁，lock必须手动。
4. Syn线程1阻塞，线程2会无限等待，而lock不会。
5. Syn可重入锁，不可中断，非公平。lock可重入锁，可以判断所，可以是否公平。（可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。）
6. SYN适合少量的同步问题，lock适用于大量。

# 通讯死锁
* 资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。        
* 进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生死锁。       
* 通讯死锁中使用超时(timeout)来解决死锁问题

# 活锁
* 某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。
* 现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 活锁(livelock)。

# 饥饿
* 与死锁和活锁的一个非常相似的问题是 饥饿(starvvation)。对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。
* 我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。


# 线程协作
* 管程法（并发协作模式，“生产者消费者模式”）        
    * 生产者：负责产生数据的模块（可能是方法，对象，线程，进程）     
    * 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）     
    * 缓冲区：消费者不直接使用生产者的数据，生产者将数据放入缓冲区，消费者从缓冲区拿       

* 信号灯法
    * 利用一个标志位，生产者消费者交替。


