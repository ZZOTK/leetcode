# 类加载器
在JVM中有三类ClassLoader构成：
* 启动类（或根类）加载器（Bootstrap ClassLoader）
* 扩展类加载器（ExtClassLoader） 
* 应用类加载器（AppClassLoader）       

不同的类加载器负责不同区域的类的加载。

## 双亲委派机制

![img.png](classloader.png)

双亲委派机制的目的是为了保证Java核心库的类型安全。     
所有Java应用都至少需要引用java.lang.Object类，在运行时这个类需要被加载到Java虚拟机中。如果该加载过程由自定义类加载器来完成，可能就会存在多个版本的java.lang.Object类，而且这些类之间是不兼容的。
通过双亲委派模型，对于Java核心库的类的加载工作由启动类加载器来统一完成，保证了Java应用所使用的都是同一个版本的Java核心库的类，是互相兼容的。        

**一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。**

具体步骤：        
1.类加载器收到类加载的请求。     
2.将这个请求向上委托给父类加载器去完成，一直向上委托直到**启动类加载器**     
3.启动加载器检查是否可以加载当前类，能就加载，使用当前加载器。不能，抛出异常，交给子类加载器去实现。     

面试问题:
- 为什么需要双亲委派机制?（也就是双亲委派的优点）
  * 双亲委派机制使得类加载出现层级，父类加载器加载过的类，子类加载器不会重复加载，可以**防止类重复加载**；
  * 使得类的加载出现优先级，**防止了核心API被篡改**，提升了安全，所以越基础的类就会越上层进行加载，反而一般自己的写的类，就会在应用程序加载器（Application）直接加载。
- 如何打破双亲委派？
  * 自定义类加载器，重写loadClass方法
    * java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。
  * 使用线程上下文类加载器

## tomcat的类加载及他如何打破双亲委派机制

# 沙箱安全机制
不做重点。       
Java安全模型的核心就是Java沙箱（sandbox）        
* 沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

所有的Java程序运行都可以指定沙箱，可以定制安全策略。

组成沙箱的基本组件：      

* 字节检验码
* 类加载器 ：**使用双亲委派机制**。
* 存取控制器（access controller）
* 安全管理器（security manager）
* 安全软件包（security package）

# Native关键字
Java在内存区域中专门开辟了一块标记区域——本地方法栈，用来登记native方法，凡是带了native关键字的，会进入到本地方法栈中，调用本地方法接口（JNI），在最终执行的时候，加载本地方法库中的方法通过JNI     
* 凡是带了native关键字的，就说明Java的作用范围达不到了，会去调用底层C语言的库
* JNI的作用：扩展Java的使用，融合不同的编程语言为Java所用，不过最初是想融合C，C++的，因为Java诞生的时候，C，C++横行，想要立足的话就要有能调用C的程序
* 本地方法栈：具体做法是，在Native Method Stack中登记native方法，在执行引擎执行的时候加载Native Libraies【本地库】


# 三种jvm
* Sun公司 HotSpot
* BEA JRockit 最快的JVM
* IBM J9VM 出色的垃圾回收机制，可以运行在小平台（嵌入式）

我们学习和使用的都是**HotSpot**

HotSpot对象创建的流程：

![img_1.png](HotSpot.png)

# jVM内存模型
![img_1.png](jvm1.6.png)

JVM 内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。

JVM1.8的模型

![img_1.png](jvm1.8.png)

## PC寄存器
每个线程都有一个程序计数器， 是线程私有的，就是一个指针， 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令, 是一个非常小的内存空间，几乎可以忽略不计      

### Q：程序计数器为什么是私有的?
程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。

### Q：虚拟机栈和本地方法栈为什么是私有的?
为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。

## 方法区
* 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间；
* **静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池**存在方法区中，但是实例变量存在堆内存中，和方法区无关。
* 常量池jdk1.7之前在方法区，1.8移动到了堆中

## 栈 
栈中存放 ： 8大基本类型 + 对象的引用 + 实例的方法
* 栈内存，主管程序的运行，生命周期和线程同步；
* 线程结束，栈内存也就释放了，对于栈来说**不存在垃圾回收问题**，一旦线程结束，栈就Over了
* 程序开始时，main函数先进栈，最后出栈。所以执行的时候main方法先执行最后结束。

栈帧运行图：

![img_1.png](stack_1.png)

java中每执行的一个方法都会产生栈帧。        
每个入栈的方法会保存一些地址，包括子帧父帧。先入栈的就会去找子帧，子帧结束会回到父帧。
栈到堆得关系：

![img.png](img.png)

* jdk1.7之后，**常量池从方法区移到了堆中**

创建一个class类，先压入栈中，从栈中依着地址找到堆中的位置，实例化在堆中。     

## 堆
类加载器读取了类文件后，一般把 **类，方法，常量，变量**，保存我们所有引用类型的真实对象放在堆中。

堆内存中还要细分为三个区域：
* 新生区（伊甸园区）young/new
  * 类诞生和成长的地方，甚至死亡  
  * 包含伊甸园区，两个幸存者区（from区 和 to区 ， 谁空谁是 to区）  
* 养老区 old
  * 新生区没干掉，没杀死的来到了养老区
* 永久区 perm
  * 这个区域是常驻内存的。用来存放JDK自身携带的Class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，这个区域不存在垃圾回收！当关闭VM虚拟机就会释放这个区域的内存。
  * jdk1.6 之前：永久代，常量池是在方法区中；
  * jdk1.7 ：永久代，但是慢慢退化了，去永久代，**常量池在堆中**
  * jdk1.8 之后：**无永久代**，常量池在**元空间**。
  * 一个启动类加载了大量的第三方jar包；Tomcat部署了太多的应用；大量动态生成的反射类等 不断的被加载，直到内存满，就会出现OOM(堆溢出)。
![img_1.png](heap.png)
    
## Q：为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

* 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。     

* 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

OOM（堆溢出）之后的处理方法：
* 尝试扩大堆内存去查看内存结果
* 若不行，分析内存，看一下是哪个地方出现了问题（专业工具）（一行行dubug分析不现实）
  * 能够看到代码第几行出错：**内存快照**分析工具，MAT（eclipse），Jprofiler 
    
MAT，Jprofiler作用：    
* 分析Dump内存文件，快速定位内存泄漏
* 获得堆中的数据
* 获得大的对象

## 补充    
* 方法区和堆**线程共享**！
* 栈和PC寄存器**线程不共享**！ 

## JVM优化
1. 监控安全点看看JVM到底发生了什么？
在JVM启动参数的GC参数里，多加一句:
> -XX:+PrintGCApplicationStoppedTime

它就会把全部的JVM停顿时间（不只是GC），打印在GC日志里。

2. 将新对象预留在新生代

由于 Full GC 的成本要远远高于 Minor GC ，因此尽可能将对象分配在新生代，在JVM 调优中，可以为应用程序分配一个合理的新生代空间，以最大限度避免新对象直接进去老年代。

| 空间                          | 命令行选项                      |占用倍数                     |
| ---------------------------- | -------------------------------|-----------------------------|
| java堆                        | -Xms和-Xmn 设置堆的最大和初始值       |3~4倍FULL GC后老年代空间占用量 |
| 永久代                        | -XX：PermSize  -XX：MaxPermSize       |1.2~1.5倍FULL GC后老年代空间占用量 |
| 新生代                        | -Xmn                            |3~4倍FULL GC后老年代空间占用量 |
| 老年代                       | JAVA堆减去新生代大小             |2~3倍FULL GC后老年代空间占用量 |


3. 调整垃圾回收策略 
   
> -XX：+UseParallelGC（新生代使用并行回收收集器）

> -XX：ParallelGCThreads=20（垃圾回收的线程数）

> -XX：+UseParallelOldGC （老年代使用并行回收收集器）

# GC（垃圾回收）

GC作用于方法区与堆
    
## 复制算法
![img_1.png](bjqc.png)

* 每次GC都会将伊甸园区活的对象移到幸存者区。伊甸园区gc后是空的
* 幸存者区会将活的对象从from区复制到to区，此时from区变空，变为to区，to区变为from区。保证一个空的to区。
* 一个对象经历了多次gc（默认为15次）仍然没有死，就会进入养老区。（-XX -MaxTenuringThreshold = 5 通过这个参数设置多少次进人老年区）
* 好处：没有内存的碎片
* 坏处：浪费了内存空间，多了一半空间永远是空.

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor(from和to) 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

## 如何判断是不是垃圾需要回收
1. 引用计数法

![img_1.png](yinyongjishu.png)

* 谁引用次数为0就清除
* 会出现相互引用不清楚的问题
* 低效，且计数器本身消耗内存，jvm中基本不使用。

2. 可达性分析算法 
   
通过一系列的‘’GC Roots‘’对象作为起点进行搜索，如果在‘’GC Roots‘’和对象之间没有可达的路径(引用链)，则称该对象是不可达的，被判定不可达的对象不一定会成为可回收对象。被判定不可达的对象至少要经历两次标记过程，如果在这两次标记过程中扔没有逃脱成为可回收对象的可能性，则基本就成为可回收的对象了。

![img_1.png](gcroots.png)

GC Roots 对象（4个）：
* 虚拟机栈（栈帧中的本地变量）中引用的对象。虚拟机栈中的引用的对象，我们在程序中正常创建一个对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存在虚拟机的栈中，如果对象的生命周期结束了，那么引用就回从虚拟机栈中出栈，因此如果在虚拟机占中存在引用，就说明这个对象还在被使用。
* 方法区中类静态属性引用的对象。由于在虚拟机栈是线程私有的，全局静态对象会保存在方法区中。
* 方法区中常量引用的对象。**final关键字修饰**
* 本地方法栈中（Native方法）引用的对象。Java调用C++或C代码，会使用native方法，JVM中会有一块本地方法栈，用于保存这些对象的引用。

即使在可达性分析算法中对象到GC Roots 的应用链不可达，也并非是”非死不可“，这些对象暂时处于”缓刑“阶段，要真正的宣告一个对象死亡，至少要要经历再次标记过程。

* 第一次标记并进行筛选。条件：此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize(）方法被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行“，对象被虚拟机回收。
* 第二次标记。如果该对象被判定为有必要执行finalize()方法，那么这个对象会被放置到一个名为F-Queue的队列中，并在稍后由虚拟机自行建立的优先级比较低的线程Finalizer去执行。这里的‘执行’是虚拟机会触发finalize()方法。finalize()方法是对象逃离死亡的最后一次自救，稍后GC将对F-Queue进行小规模的标记，如果对象重新与应用链上的对象建立联系，第二次标记会将他移除“即将回收”的集合。

![img_1.png](gcsteps.png)

* finalize()是Object里面的一个方法，当一个堆空间中的对象没有被栈空间变量指向的时候，这个对象会等待被java回收

如果对象的finalize()方法自己执行了，那么就丢入队列。如果对象的finalize()方法时虚拟机执行的，那么第二次标记就回收。

## 什么是FullGC，一般什么情况下触发
Full GC 是清理整个堆空间—包括年轻代和永久代。

触发条件：
1. System.gc()方法的调用。
2. 老年代空间不足。老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
3. Permanet Generation空间满了。Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。
4. 由Eden区、From区向To 区复制时，对象大小大于To 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

## 触发了FULLGC但是老年代没有减少可能是什么原因？

1. 不恰当的使用分页（未分页/浅分页），比如一次不分页查出1000w结果集，堆影响较大
2. 查询结果集过大（类似于上条）
3. 元空间太小触发的fullgc

## metaspace占用空间异常，堆占用异常怎么排查

# 常见的垃圾回收器
### Serial（串行）收集器
是单线程收集器。仅使用一条垃圾收集线程去完成垃圾收集，在垃圾收集工作的时候必须暂停其他所有工作线程。

新生代采用复制算法，老年代采用标记-整理算法。

### ParNew收集器
Serial收集器的多线程版本。他与Serial收集器可以与CMS收集器共同工作。

### Parallel Scavenge收集器
类似ParNew收集器。但是他的关注点是吞吐量。即尽快的垃圾回收。Parallel Scavege收集器提供了非常多的参数去调整停顿时间与吞吐量。
* -xx:+UseParallelGC:使用Parallel收集器 + 老年代串行
* -xx:+UseParallelOldGC:使用Parallel收集器+老年代并行

新生代采用复制算法，老年代采用标记-整理算法。

### CMS收集器
CMS收集器是一种以获取最短停顿时间为目标的收集器。也是第一款真正意义上的并发收集器，第一次实现了垃圾收集线程与用户线程同时工作。

CMS是用的是标记-清除 算法。

![img_1.png](CMS.png)

* 初始标记：暂停其他所有线程，标记所有与root相连的对象，速度很快。
* 并发标记：同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。
    * 这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。 因为⽤户线程可能会不断的更新引⽤域，所以 GC线程⽆法保证可达性分析的实时性。
    * 这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。
* 重新标记： 重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对象的标记记录
    * 这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短
* 并发清理
    * 开启⽤户线程，同时GC线程开始对为标记的区域做清扫

缺点：
1. 对CPU资源敏感
2. 无法处理浮动垃圾
3. 使用的回收方法会使内存产生大量空间碎片

### G1收集器
G1 (Garbage-First)是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器. 以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征.

G1收集器有以下特征：
* 并发与并行
    * 原本停顿java线程执行的GC操作，G1收集器可以以并发的方式让java程序继续执行。
* 分代收集
    * G1不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念
* 空间整合
    * 从整体来看是“标记整理”，从局部来看是“复制”算法。
* 可预测的停顿
    * 能让使用者明确指定在一个长度为M毫秒的时间片段内停顿。
    
G1收集器步骤：
1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

## JVM中的Stop-The-World
Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。

停顿的原因: 
* 分析工作必须在一个能确保一致性的快照中进行
* 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
* 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

## JVM安全点SafePoint
在JVM里面引入了一个叫安全点（Safe Point）的东西来避免STW。GC的目的是帮助我们回收不再使用的内存，在多线程环境下这种回收将会变得非常复杂，要安全地回收需要满足一下两个条件：

1. 堆内存的变化是受控制的，最好所有的线程全部停止。
2. 堆中的对象是已知的，不存在不再使用的对象很难找到或者找不到即堆中的对象状态都是可知的。

为了准确安全地回收内存，JVM是在Safe Point点时才进行回收，所谓Safe Point就是Java线程执行到某个位置这时候JVM能够安全、可控的回收对象，这样就不会导致回收正在使用的对象。

安全点是什么：
1. 从线程的角度，安全点是代码执行中的一些特殊位置，当线程执行到这些特殊的位置，如果此时在GC，那么在这个地方线程会暂停，直到GC结束。
2. GC的时候要挂起所有活动的线程，因此线程挂起，会选择在到达安全点的时候挂起。
3. 安全点这个特殊的位置保存了线程上下文的全部信息。说白了，在进入安全点的时候打印日志信息能看出线程此刻都在干嘛。

使线程中断一般有两种方式：主动式和被动式。

* 主动式JVM设置一个全局变量，线程去按照某种策略检查这个变量一旦发现是Safe Point就主动挂起。
    * HostSop虚拟机采用的是主动式使线程中断。
* 被动式就是发个信号，例如关机、Control+C，带来的问题就是不可控，发信号的时候不知道线程处于什么状态。

安全点主要在以下位置设置：
1. 循环的末尾
2. 方法返回前
3. 调用方法的call之后
4. 抛出异常的位置

安全区域： 

安全点完美的解决了如何进入GC问题，实际情况可能比这个更复杂，但是如果程序长时间不执行，比如线程调用的sleep方法，这时候程序无法响应JVM中断请求这时候线程无法到达安全点，显然JVM也不可能等待程序唤醒，这时候就需要安全区域了。

安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方GC都是安全的，安全区域可以看做是安全点的一个扩展。线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样GC时就不用管进入安全区域的线程了，线程要离开安全区域时就检查JVM是否完成了GC Roots枚举，如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。






