# Nosql四大分类

## KV键值对
* 新浪 ：Redis
* 美团 ：Redis + Tair
* 阿里、百度 ：Redis + memecache

## 文档型数据库（bson格式，类似json）
* MongoDB 
  * MongoDB是一个基于分布式文件存储的数据库，C++编写，处理大量数据文档。
  * MongoDB是一个介于关系型数据库与非关系型数据库中间的产品。是非关系型数据库中功能最多，最像关系型数据库的。
    
*ConthDB

## 列存储数据库
* HBase
* 分布式文件系统

## 图关系数据库
* 存放拓扑关系，如Neo4j，InfoGrid

# Redis概述
* Redis（Remote Dictionary Server )，即远程字典服务。官方表示有100000+的QPS（每秒查询效率）
* Redis可以做到 ： 内存存储，持久化（rdb，aof），发布订阅系统，地图信息分析，计时器，计数器。。。
* 特性 ：数据多样，持久化，集群，事务
* Redis为单线程（核心模块）（网络I/O已经有多线程）
  * Redis是基于内存操作的，cpu不是他的性能瓶颈。
  * Redis的瓶颈是内存大小和网络带宽。
    
## Q：Redis为什么单线程还这么快
* 多线程由于CPU上下文切换，不一定比单线程效率高。
* Redis将所有数据都放在内存中，所以单线程操作速度很快。
* 高效数据结构。  
* 合理的数据编码。  
* I/O使用多路复用技术。Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。
* Redis的高并发能力，主要看它的网络模型，单线程的redis是不如多线程的mc的。

## Q : 说一下 Redis 和 Memcached 的区别和共同点
共同点 ： 
* 都是基于内存的数据库，一般都用来当做缓存使用。
* 都有过期策略。
* 两者的性能都非常高

不同点 ： 
* **Redis 支持更丰富的数据类型**（支持更复杂的应用场景）。Memcached 只支持最简单的 k/v 数据类型。Redis还提供 list，set，zset，hash 等数据结构的存储。
* **Redis 支持数据的持久化**，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。
* Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
* Memcached 是多线程，非阻塞 IO 复用的网络模型；**Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）
* **Redis 支持发布订阅模型、Lua 脚本、事务等功能**，而 Memcached 不支持。并且，Redis 支持更多的编程语言。
* Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

# Redis数据类型
* Redis有五大数据类型 ：
  * String
  * List
  * Set
  * Hash
  * Zset
   
* 三种特殊的数据类型 : 
  * geospatial 地理位置
  * Hyperloglog 基数统计
  * Bitmap 位图场景 

# Redis事务

Redis事务**没有隔离级别**的概念，也不支持roll back。        
Redis单条命令保证原子性，但是**Redis事务不保证原子性**。         
Redis事务顺序：
* 开启事务 （multi）
* 命令入队 （....）
* 执行事务 （exec）

如果Redis事务中有一条命令语法错误，那只有那一条不执行，其他仍会执行。

悲观锁 ： 
* 什么时候都可能出问题，所以任何操作都加锁。 

乐观锁 ：
* 不上锁，更新数据时去判断一下，在此期间是否有人修改过这个数据。
* 开始时获取version，更新时比较version。（Mybaits）

Redis使用乐观锁。 Redis使用watch监控。watch充当乐观锁。（可用于秒杀）。


# RDB持久化

> RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。

## 触发持久化
可以手动触发与自动触发。

### 手动触发
手动使用save命令和bgsave命令都可以生成RDB文件.      
* save ：save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。
* bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。

所以save命令现在已基本不使用。

### 自动触发
* 自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。
  * Redis的save m n，是通过serverCron**周期函数**、dirty**计数器**、和lastsave**时间戳**来实现的。
    * serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足。
    * dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。
    * astsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。  
* 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点
* 执行shutdown命令时，自动执行rdb持久化，如下图所示：

RDB优点：
* 适合大规模数据恢复。
* 对数据的完整性要求不高。  
* redis默认使用RDB持久化，比较高效。

RDB缺点：
* 需要一定的时间操作。
* fork进程会占用一定的内存空间。

# AOF持久化 
