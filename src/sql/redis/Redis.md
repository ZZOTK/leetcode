# Nosql四大分类
* KV键值对
    * 新浪 ：Redis
    * 美团 ：Redis + Tair
    * 阿里、百度 ：Redis + memecache
* 文档型数据库（bson格式，类似json）
    * **MongoDB** 
        * MongoDB是一个基于分布式文件存储的数据库，C++编写，处理大量数据文档。
        * MongoDB是一个介于关系型数据库与非关系型数据库中间的产品。是非关系型数据库中功能最多，最像关系型数据库的。
    
    * ConthDB
* 列存储数据库
    * HBase
    * 分布式文件系统
* 图关系数据库
    * 存放拓扑关系，如Neo4j，InfoGrid

# Redis概述
* Redis（Remote Dictionary Server )，即远程字典服务。官方表示有100000+的QPS（每秒查询效率）
* Redis可以做到 ： 内存存储，持久化（rdb，aof），发布订阅系统，地图信息分析，计时器，计数器。。。
* 特性 ：数据多样，持久化，集群，事务
* Redis为单线程（核心模块）（网络I/O已经有多线程）
  * Redis是基于内存操作的，cpu不是他的性能瓶颈。
  * Redis的瓶颈是内存大小和网络带宽。
    
## Q：Redis为什么单线程还这么快
* 多线程由于CPU上下文切换，不一定比单线程效率高。
* Redis将所有数据都放在内存中，所以单线程操作速度很快。
* 高效数据结构。  
* 合理的数据编码。  
* I/O使用多路复用技术。Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。
  * 什么是I/O多路复用？
  * 哪种I/O多路复用？  
* redis6.0之前使用的是是用loop线程读取epoll 返回，然后逐一执行crud 这样做，读取客户端数据跟服务器增删改查都在一起，缺点就是并发可能存在瓶颈。
* redis6.0之后也是使用了多线程技术。worker主线程负责数据的计算。IO子线程负责网络数据的读写和协议解析。执行命令依然是单线程顺序执行。
    * Redis6.0的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。

* Redis的高并发能力，主要看它的网络模型，单线程的redis是不如多线程的memecache的。

### Q：什么是I/O多路复用，redis用了哪种I/O多路复用
单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。这就是I/O多路复用

select, poll, epoll 都是I/O多路复用的具体的实现，在redis中，我们使用的是epoll


## Q : 说一下 Redis 和 Memcached 的区别和共同点
共同点 ： 
* 都是基于内存的数据库，一般都用来当做缓存使用。
* 都有过期策略。
* 两者的性能都非常高

不同点 ： 
* **Redis 支持更丰富的数据类型**（支持更复杂的应用场景）。Memcached 只支持最简单的 k/v 数据类型。Redis还提供 list，set，zset，hash 等数据结构的存储。
* **Redis 支持数据的持久化**，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。
* Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
* Memcached 是多线程，非阻塞 IO 复用的网络模型；**Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）
* **Redis 支持发布订阅模型、Lua 脚本、事务等功能**，而 Memcached 不支持。并且，Redis 支持更多的编程语言。
* Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

# Redis数据类型
Redis有五大数据类型 ：
* String
  * 使用最多。一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。
* List
  * 发布与订阅或者说消息队列、慢查询。
* Set
  * 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景
* Hash
  * 系统中对象数据的存储。
* Zset
  * 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。
   
三种特殊的数据类型 : 
* geospatial 地理位置
* Hyperloglog 基数统计
* Bitmap 位图场景 

# Redis事务

Redis事务**没有隔离级别**的概念，也不支持roll back。        
Redis单条命令保证原子性，但是**Redis事务不保证原子性**。         
Redis事务顺序：
* 开启事务 （multi）
* 命令入队 （....）
* 执行事务 （exec）

如果Redis事务中有一条命令语法错误，那只有那一条不执行，其他仍会执行。

悲观锁 ： 
* 什么时候都可能出问题，所以任何操作都加锁。 

乐观锁 ：
* 不上锁，更新数据时去判断一下，在此期间是否有人修改过这个数据。
* 开始时获取version，更新时比较version。（Mybaits）

Redis使用乐观锁。 Redis使用watch监控。watch充当乐观锁。（可用于秒杀）。


# RDB持久化

> RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。

## RDB持久化流程
![img.png](rdb.png)

具体流程 ：
1. Redis父进程首先判断：当前是否在执行save，或bgsave的子进程，如果在执行则bgsave命令直接返回。
2. 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令
3. bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令
4. 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换
5. 子进程发送信号给父进程表示完成，父进程更新统计信息

## 触发持久化
可以手动触发与自动触发。

### 手动触发
手动使用save命令和bgsave命令都可以生成RDB文件.      
* save ：save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。
* bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。

所以save命令现在已基本不使用。

### 自动触发
* 自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。
  * Redis的save m n，是通过serverCron**周期函数**、dirty**计数器**、和lastsave**时间戳**来实现的。
    * serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足。
    * dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。
    * astsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。  
* 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点
* 执行shutdown命令时，自动执行rdb持久化，如下图所示：

RDB优点：
* 适合大规模数据恢复。
* 对数据的完整性要求不高。  
* redis默认使用RDB持久化，比较高效。

RDB缺点：
* 需要一定的时间操作。
* fork进程会占用一定的内存空间。

# AOF（Append Only File）持久化 

> AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。

## 重写
![img.png](aof.png)

如果文件超过64m，就会触发重写机制

AOF优点：
* 每一次修改都同步，文件完整性好
* 默认每秒同步一次，可能会丢失一秒的数据
* 从不同步，效率最高

AOF缺点：
* 文件大
* 恢复速度慢
* 性能影响大

## 持久化补充
1. 持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。
2. RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。
3. AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。
4. 一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞(cpu阻塞)、AOF追加阻塞（硬盘阻塞）等。

# 主从复制
主从复制，是指将一台redis服务器的数据，复制到其他redis服务器。前者成为主节点，后者从节点。

数据复制是单向的，只能由主节点到从节点

主节点以写为主，从节点以读为主（读写分离）

## 主从复制的作用
1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的以中冗余方式。
2. 故障恢复：主节点出现问题时，可以由从节点提供服务，快速故障恢复。
3. 复杂均衡：主从复制基础上，读写分离，尤其是写少读多的情况下，分担服务器负载，提高性能。
4. 高可用(集群)基石：主从复制还是**哨兵模式**和集群能够实施的基础。

一般来说，工程中一台redis不可能，原因：
1. 从结构中，单个服务器会发生单点故障，且负载压力大。
2. 从容量上，单个redis服务器内存容量有限。

## 主从复制原理
1. 从机成功连接到主机（master）后，发送一个sync同步命令
2. master接到后，启动后台存盘。完成后，master会将整个数据发给从机，并完成一次同步
    * 全量复制： 从机接受到数据后，将其存盘并加载到内存。
    * 增量复制： master继续将新的收集到的修改命令依次传给从机，完成同步。

只要重新连接到主机，就会执行一次全量复制。

## 哨兵模式
当主服务器宕机后，需要手动把一台服务器切换为主服务器。费事费力，且一段时间内服务器不可用。我们这时采用哨兵模式解决整个问题。          
哨兵模式是一种特殊的模式。       
* 哨兵是一个独立的进程，哨兵通过发送命令，等待redis服务器响应，从而监控多个redis实例。
* 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。

用文字描述一下故障切换（failover）的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。

# Redis缓存穿透，击穿与雪崩（重点）
服务器的高可用问题。

## 缓存穿透（查不到）

用户查询一个数据，redis内存内没有（缓存没命中），就向持久层数据库查询，也没有，一次查询失败。当客户很多时，缓存都没命中，会给持久层数据库带来巨大压力，出现缓存穿透。

解决方案 ： 
1. **布隆过滤器** ： 给缓存加一个过滤器
   * 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，现在控制层校验，不符合则丢弃，避免了对持久层数据库的查询压力。
2. 缓存空对象 ： 存储层不命中后，返回一个**加入过期时间的空对象**并将其加入缓存。
   * 空值被缓存就以为中缓存需要更多的空间。
   * 即使对空值设置了过期时间，还是会存在缓存层与存储层数据不一致的一段时间，对业务一致性有影响。
    
## 缓存击穿（查太多）

缓存击穿，是指一个key非常热点，超大并发集中对这一个点访问。当这个key失效的时候，大并发直接请求数据库，使数据库瞬间压力过大。

解决方案：
1. 设置热点数据不过期。
2. 加互斥锁（分布式锁）： 
    * 分布式锁 ： 对于每个key同时只有一个线程去查询后端服务。其他线程没有分布式锁的权限，只能等待。这个方法将高并发的压力转移到分布式锁，对锁要求高。
    
## 缓存雪崩

指在一个时间段，缓存集中过期失效，redis宕机。比如双十一0点一波抢购集中加入缓存，然后1点缓存集中过期。此时的访问直接到达数据库。

解决方案 ：
1. redis高可用 ： 多搭几台redis，就是搭建集群（异地多活）
2. 限流降级 ： 缓存失效后，通过加锁或是队列控制读数据库与写缓存的线程数。
3. 数据预热 ： 正式部署前，预先访问数据，让缓存失效的时间尽量均匀。

## 如何保证缓存与数据库数据的一致性
由于引入了缓存，短时间内可能存在数据库与缓存不匹配。          
Cache Aside Pattern（旁路缓存模式）：更新DB时，需要直接删除cache。如果更新数据库成功，而删除缓存失败的话，有以下解决方案：          
1. 缓存失效时间变短 ：治标不治本
2. 增加cache更新重试机制 ： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。



. 在数据更新的同时立即去更新缓存；
4. 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。
   要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。