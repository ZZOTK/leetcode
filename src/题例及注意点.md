##二分查找注意点
leetcode 34,
>1.普通二分查找
    
    public int binarySearch(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        //此时区间长度很重要。[left,nums.length-1],[left,nums.length)
        //[2,2]区间长度为1，[2,2)区间长度为0
        while(left<=right){
            //此时的=号是否需要很重要。
            //带等于，left=right+1才跳出
            //不带等于，left=right就跳出
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]<target){
                left=mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }
        }
        return -1;
    }
    
>2.寻找二分查找的左边界   

比如数组int[] nums={1,2,2,3,4},我们需要找到第一个2的位置,称为用二分查找找到左侧边界。   
    
    public int binarySearcLeft(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        //搜索区间[left,right]
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<targrt){
                //搜索区域变为[mid+1,right]
                left=mid+1;
            }else if(nums[mid]>target){
                //搜索区域变为[left,mid-1]
                right=mid-1;
            }else if(nums[mid]==targrt){
                //收缩右侧边界
                right=mid-1;
            }
        }
        //检查出界情况
        if(left>=nums.length||nums[left]!=target){
            return -1;
        }
        return left;
    }
    
>3.寻找二分查找的右侧边界

    public int binarySearcLeft(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1;
            }else if(nums[right]>target){
                right=mid-1;
            }else if(nums[mid]==target){
                //收缩左边界
                left=mid+1;
            }   
        }
        //检查出界情况
        if(right<0||nums[right!=target){
            return -1;
        }
        return right;
    }

##打家劫舍问题
>1.leetcode198      
 
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。    
dp算法，int[] dp记录偷到第n家钱最多的钱。  
dp[n]=Math.max(dp[n-2]+nums[n],dp[n-1])


>2.leetcode213

强盗依然不能抢劫相邻的房子，输入依然是一个数组，但是告诉你这些房子不是一排，而是围成了一个圈。
也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。  
分为三个情况。同上算法，我们求[0,n-1) , (0,n-1] , (0,n-1)三个范围内的最大值。显然，（0，n-1）的情况已经被
包含。只需要求[0,n-1) , (0,n-1]这两个情况。

>3.leetcode322 

树形dp。   


##背包问题
>1.01背包问题

有 N 件物品和一个容量是 V 的背包。`每件物品只能使用一次。`第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。




    