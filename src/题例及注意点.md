##二分查找注意点
leetcode 34,
>1.普通二分查找
    
    public int binarySearch(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        //此时区间长度很重要。[left,nums.length-1],[left,nums.length)
        //[2,2]区间长度为1，[2,2)区间长度为0
        while(left<=right){
            //此时的=号是否需要很重要。
            //带等于，left=right+1才跳出
            //不带等于，left=right就跳出
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]<target){
                left=mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }
        }
        return -1;
    }
    
>2.寻找二分查找的左边界   

比如数组int[] nums={1,2,2,3,4},我们需要找到第一个2的位置,称为用二分查找找到左侧边界。   
    
    public int binarySearcLeft(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        //搜索区间[left,right]
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<targrt){
                //搜索区域变为[mid+1,right]
                left=mid+1;
            }else if(nums[mid]>target){
                //搜索区域变为[left,mid-1]
                right=mid-1;
            }else if(nums[mid]==targrt){
                //收缩右侧边界
                right=mid-1;
            }
        }
        //检查出界情况
        if(left>=nums.length||nums[left]!=target){
            return -1;
        }
        return left;
    }
    
>3.寻找二分查找的右侧边界

    public int binarySearcLeft(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1;
            }else if(nums[right]>target){
                right=mid-1;
            }else if(nums[mid]==target){
                //收缩左边界
                left=mid+1;
            }   
        }
        //检查出界情况
        if(right<0||nums[right!=target){
            return -1;
        }
        return right;
    }
   

##打家劫舍问题
>1.leetcode198      
 
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。    
dp算法，int[] dp记录偷到第n家钱最多的钱。  
dp[n]=Math.max(dp[n-2]+nums[n],dp[n-1])


>2.leetcode213

强盗依然不能抢劫相邻的房子，输入依然是一个数组，但是告诉你这些房子不是一排，而是围成了一个圈。
也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。  
分为三个情况。同上算法，我们求[0,n-1) , (0,n-1] , (0,n-1)三个范围内的最大值。显然，（0，n-1）的情况已经被
包含。只需要求[0,n-1) , (0,n-1]这两个情况。

>3.leetcode322 

树形dp。   


##背包问题
>1.　01背包问题

有 N 件物品和一个容量是 V 的背包。`每件物品只能使用一次。`第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。        
        
定义一个二阶矩阵dp[N+1][V+1],
这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候第0列表示背包的体积为0的时候，即不能装任何东西的时候 
dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值     
对于dp[i][j]有两种情况：        
　　1.不选择当前的第i件物品/第i件物品比背包容量要大       
　　　　　　　　　　　　dp[i][j] = dp[i-1][j]       
　　2.选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：        
　　　　　当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值       
　　　　　　　　　　dp[i][j] = dp[i-1][j-v[i]] + w[i]       
　　　dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；     
　　　即：      
　　　if(j >= v[i]):      
　　　　　　dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])      
　　　else:       
　　　　　　dp[i][j] = dp[i-1][j]     

    import java.util.Scanner;
    
    public class Main{
        public static void main(String[] args) throws Exception {
            // 读入数据的代码
            Scanner reader = new Scanner(System.in);
            // 物品的数量为N
            int N = reader.nextInt();
            // 背包的容量为V
            int V = reader.nextInt();
            // 一个长度为N的数组，第i个元素表示第i个物品的体积；
            int[] v = new int[N + 1] ;
            // 一个长度为N的数组，第i个元素表示第i个物品的价值；
            int[] w = new int[N + 1] ;
    
            for (int i=1 ; i <= N ; i++){
            //读入是第一个数索引为1
                // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值
                v[i] = reader.nextInt();
                w[i] = reader.nextInt();
            }
            reader.close() ;
    
            // 正式工作的代码

            int[][] dp = new int[N+1][V+1];
            dp[0][0] = 0;
            for(int i = 1; i <= N; i++){
                for(int j = 0; j <= V; j++){
                    if(j >= v[i]){
                        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);
                    }else{
                        dp[i][j] = dp[i-1][j];
                    }
                }
            }
            //压缩为一维dp数组
                int[] dp = new int[V+1];
                dp[0] = 0;
                for(int i = 1; i <= N; i++){
                    for(int j = V; j >= v[i]; j--){
                        dp[j] = Math.max(dp[j], dp[j-v[i]] + w[i]);
                    }
                }
                System.out.println(dp[V]);
                //一维的输出
          
            //二维的输出
            System.out.println(dp[N][V]);
        }
    }
   
补充：     
1.01背包装到值为A有多少种做法：leetcode494       
2.01背包能否装到值为A ： leetcode416       


>2.完全背包问题

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。        
第 i 种物品的体积是 vi，价值是 wi。      
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

    //模仿01背包，多维的dp。dp[i][j]记录前i个物品放入j空间的最大值。
        int[][] dp=new int[N+1][V+1];
        for(int i=1;i<=N;i++){
            for(int j=0;j<=V;j++){
                if(j>=v[i]){
                    //此时的状态方程，比较的大小
                    dp[i][j]=Math.max(dp[i][j-v[i]]+w[i],dp[i-1][j]);
                }else{
                    dp[i][j]=dp[i-1][j];
                }
               
            }
        }
        System.out.println(dp[N][V]);
        
    //初步优化为一维数组
        int[] dp=new int[V+1];
        for(int i=1;i<=N;i++){
            for(int j = V; j >= v[i]; j --){
                //逐一找最大值，增加循环，用变量k遍历计算最大值。
                for(int k = 0; j-k* v[i] >= 0; k ++){
                    dp[j] = Math.max(dp[j] , dp[j - k * v[i]] + k * w[i]);
                }
            }
        }
        System.out.println(dp[V]);  
    
    //再优化。
        int[] dp=new int[V+1];
        for(int i=1;i<=N;i++){
            for(int j =  v[i]; j <= V;  j ++){
                dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
            }
        }
        System.out.println(dp[V]);
        
>3 多重背包问题

有 N 种物品和一个容量是 V 的背包。        
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。        
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。        
思路：     
　　参考完全背包问题，就是将完全背包中的数量限制改为si.       
优化：     
　　利用二进制，将背包数量分解，变为01背包问题。
         
        //直接做法。
        int[] dp = new int[V+1];
        for(int i = 1; i <= N; i ++){
            for(int j = V; j >= v[i]; j --){
            //此处加入一个限制条件k<=s[i]即可
            //k可以从1开始，因为0就是dp[j]
                for(int k = 1; j - k * v[i] >= 0 && k <= s[i]; k ++ ){
                    dp[j] = Math.max(dp[j], dp[j - k * v[i]] + k * w[i]);
                }
            }
        }
        System.out.println(dp[V]);       
        
        //优化的多重背包问题。        
        //将数量s分解。例如有一个体积为v，值为w，数量为7的。则分解为[v,w],[2v,2w],[4v,4w]三个物体            
        //将所有物体数量都分解。则化解为了01背包问题。       
        int maxN = 200002;
        int[] v = new int[maxN];
        int[] w = new int[maxN];
        Scanner jin = new Scanner (System.in);
        void run(){
            int n = jin.nextInt();
            int m = jin.nextInt();
            int p = 1;
            for (int i = 1; i <= n ; i++){
                int V = jin.nextInt();
                int W = jin.nextInt();
                int S = jin.nextInt();
                int k = 1;
                while (S > k){
                    v[p] = V*k;
                    w[p] = W*k;
                    S -= k;
                    k *= 2;
                    p++;
                }
                if (S > 0){
                    v[p] = V*S;
                    w[p] = W*S;
                    p ++;
                }
            }
            //到此为止，原来所有的物体分解为共p个独立的物体，每个限制使用1次，化解为01背包问题。       
            //共有p个物体，放入总体积m的背包。体积为v，价值为w
            int res = dp(p, m);
            System.out.println(res);
        }
        //同01背包问题。
        int dp(int n, int m){
            int[] f = new int[maxN];
            for (int i= 1; i <= n ; i ++){
                for (int j = m ; j>= v[i] ; j--){
                    f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
                }
            }
            return f[m];
        }
        public static void main(String[] args) {new solution().run();}
        
        //利用优先队列优化多重背包问题
        （待学习）
        
>4.混合背包问题       
        
有 N 种物品和一个容量是 V 的背包。
物品一共有三类：        
第一类物品只能用1次（01背包）；       
第二类物品可以用无限次（完全背包）；      
第三类物品最多只能用 si 次（多重背包）；      
每种体积是 vi，价值是 wi。        
si=−1 表示第 i 种物品只能用1次；       
si=0 表示第 i 种物品可以用无限次；       
si>0 表示第 i 种物品可以使用 si 次；        
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

思路：     
分类讨论。01背包可以看作只使用一次的多重背包问题。
 
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int N = sc.nextInt(); // 物品个数
            int V = sc.nextInt(); // 背包总容量
            int[] dp = new int[V + 1];
            for(int i = 0; i < N; i++){
                int v = sc.nextInt(); // 体积
                int w = sc.nextInt(); // 价值
                int s = sc.nextInt(); // 数量
                if(s == 0){
                    // 完全背包问题
                    for(int j = v; j <= V; j++){
                        dp[j] = Math.max(dp[j], dp[j - v] + w);
                    }
                }else{
                    // 多重背包问题，01背包是多重背包的特例，可以一并处理
                    s = Math.abs(s);
                    for(int j = 1; s >= j; s -= j, j *= 2){
                        for(int k = V; k >= j * v; k--){
                            dp[k] = Math.max(dp[k], dp[k - j * v] + j * w);
                        }
                    }
                    if(s > 0){
                        for(int j = V; j >= s * v; j--){
                            dp[j] = Math.max(dp[j], dp[j - s * v] + s * w);
                        }
                    }
                }
            }
            System.out.println(dp[V]);
        }
        
>5.二维背包问题

有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。
每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。     
思路: 与01背包一样，二维dp扩充为三维dp

        public int two_dimension_knapsack_problem_1(int N, int V, int M, int[] v, int[] m, int[] w){
            int[][][] dp = new int[N+1][V+1][M+1];
            for(int i = 1; i <= N; i++){
                for(int j = 1; j <= V; j++){
                    for(int k = 1; k <= M; k++){
                        if(j < v[i] || k < m[i]){
                            // 客观条件限制，不能选择当前物品N
                            dp[i][j][k] = dp[i-1][j][k];
                        }else {
                        //基本相同，多个限制
                            dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-v[i]][k-m[i]] + w[i]);
                        }
                    }
                }
            }
            return dp[N][V][M];

##二叉树
二叉树的主要思路就是递归。我们需要重点考虑每个节点该做什么，考虑递归.left和.right在操作之前还是之后
。然后写出函数。
>1.树到数组     

这类问题，最直接的就是树的前序，中序，后序，层序遍历(leetcode102)。        
将树拉直（leetcode116）


>2.树本身的变形和访问

树的反转（leetcode116），树节点指向（leetcode226）


>3.数组到树

按照一定规律将数组转为树（leetcode654)       
根据前序、中序、层序、后序中的两个数组还原(**leetcode105**）     
都使用了辅助函数bulid。重点，利用左右指针大小比较来进行return。